#! /usr/bin/env python

dev = False

from Tkinter import *
from multiprocessing import Process
import sys, threading, Queue, time

if not dev:
    import imp
    imp.load_source('pacgraph', '/usr/bin/pacgraph')
import pacgraph

colors = {'sel' : '#000',
          'uns' : '#888',
          'dep' : '#008',
          'req' : '#00F',
          'bg'  : '#FFF',
          'line': '#DDD'}

class Motion(object):
    def __init__(self):
        self.mouse = None    # prev canvas coord
        self.scale = 1.0
        self.typed = ''      # keyboard search buffer
        self.offset = (0,0)  # unzoomed coords
    def button_up(self, event):
        self.mouse = None
    def drag(self, event):
        if self.mouse is None:
            self.mouse = (event.x, event.y)
            return
        mdx = event.x - self.mouse[0]
        mdy = event.y - self.mouse[1]
        canvas.move(ALL, mdx, mdy)
        self.mouse = (event.x, event.y)
        self.offset = xy_add(self.offset, (mdx, mdy), self.scale**(-1))
    def zoom(self, event, factor):
        self.scale *= factor
        new_p = lambda p: str(max(1, int(p * 0.4 * self.scale)))
        cx,cy = origin()
        canvas.scale(ALL, cx, cy, factor, factor)
        for n,v in list(cant.items()):
            canvas.itemconfig(v.tk, font=('Monospace', new_p(v.font_pt)))
    def zoom_in(self, event):
        if self.scale*1.1 > 2:
            return
        self.zoom(event, 1.1)
    def zoom_out(self, event):
        if self.scale*0.8 < 0.1:
            return
        self.zoom(event, 0.8)
    def search(self, event):
        # prototype, eventually zoom-to-fit typed matches
        #print event.char, event.keysym, event.keycode
        ks = event.keysym
        c = event.char
        matches = []
        if ks in ['space', 'BackBpace', 'Escape', 'Delete', 'Return']:
            self.typed = ''
        if c.isalpha():
            self.typed += c
            matches = [n for n in cant if self.typed in n]
        for name in list(cant):
            if name in matches:
                color_text(name, 'sel')
            else:
                color_text(name, 'uns')

class Container(object):
    pass

def origin():
    "center of the canvas"
    return canvas.winfo_width()//2, canvas.winfo_height()//2

def xy_add(p1, p2, scale=1.0):
    "add two and scale points"
    return (p1[0]+p2[0]) / scale, (p1[1]+p2[1]) / scale

def zoom_shift(p):
    "real coords -> canvas coords"
    px,py = p
    ox,oy = motion.offset
    cx,cy = origin()
    z = motion.scale
    return z * (px - cx + ox) + cx, z * (py - cy + oy) + cy

def color_text(name, color):
    canvas.itemconfig(cant[name].tk, fill=colors[color])

def hilite(event, name, selected):
    loaded = set(cant)
    if selected:
        color_text(name, 'sel')
        for l in cant[name].links & loaded:
            color_text(l, 'dep')
        for l in cant[name].inverse & loaded:
            color_text(l, 'req')
    else:
        color_text(name, 'uns')
        for l in cant[name].all & loaded:
            color_text(l, 'uns')

def async_place(tree):
    "This is a horrible idea."
    global canvas, cant, motion
    motion.offset = origin()
    placed = []
    cant = {}
    frame_delay = 0.03  # seconds
    prev_frame = time.time()
    for name, centers in pacgraph.place(tree, detail=True):
        placed.append(name)
        node = tree[name]
        lines = [(center, cant[l].center) for l in set(placed) & node.all]
        node.lines_tk = []
        for line in lines:
            l = Container()
            l.p = line[0] + line[1]
            l.c = colors['line']
            lp2 = zoom_shift(line[0]) + zoom_shift(line[1])
            l.tk = canvas.create_line(lp2, fill=l.c)
            canvas.tag_lower(l.tk)
            node.lines_tk.append(l)
        p = node.font_pt
        center = centers[0]
        node.center = centers[0]
        tkcenter = zoom_shift((center[0], center[1]+p//4))
        node.tk = canvas.create_text(
                tkcenter[0], tkcenter[1], 
                text=name, anchor=S, fill=colors['sel'], 
                font=('Monospace', str(max(1, int(p*0.4*motion.scale)))))
        cant[name] = node
        hilite(None, name, True)
        for center in centers:
            cant[name].center = center
            tkcenter = zoom_shift((center[0], center[1]+p//4))
            for line in cant[name].lines_tk:
                line.p = tkcenter + line.p[2:]
                canvas.coords(line.tk, tkcenter + zoom_shift(line.p[2:]))
            canvas.itemconfig(cant[name].tk, fill=colors['bg'])
            canvas.coords(cant[name].tk, tkcenter)
            canvas.itemconfig(cant[name].tk, fill=colors['sel'])
            pause = prev_frame + frame_delay - time.time()
            if pause > 0:
                time.sleep(pause)
            prev_frame = time.time()
        if len(placed) >= 2:
            hilite(None, placed[-2], False)
        n = name
        canvas.tag_bind(cant[n].tk, '<Enter>', lambda e, n=n: hilite(e, n, True))
        canvas.tag_bind(cant[n].tk, '<Leave>', lambda e, n=n: hilite(e, n, False))
    hilite(None, placed[-1], False)

def main():
    global canvas, tree, motion, cant
    arch = pacgraph.Arch()
    if len(sys.argv) == 1:
        print 'Loading local repo.'
        tree = arch.local_load()
    else:
        print 'Loading repository.'
        tree = arch.repo_load()
    print 'Preparing %i nodes.' % len(tree)
    tree = pacgraph.pt_sizes(tree, 10, 100)
    print 'Hover, drag, scroll and type to control.'
    
    root = Tk()
    canvas = Canvas(root, bg=colors['bg'])
    canvas.pack(expand=1, fill=BOTH)
    canvas.tk_focusFollowsMouse()
    motion = Motion()
    cant = {}
   
    #ap = Process(target=async_place)
    ap = threading.Timer(3.0, async_place, args=[tree])
    ap.start()
    
    canvas.bind('<B1-Motion>', motion.drag)
    canvas.bind('<ButtonRelease-1>', motion.button_up)
    canvas.bind('<B2-Motion>', motion.drag)
    canvas.bind('<ButtonRelease-2>', motion.button_up)
    canvas.bind('<B3-Motion>', motion.drag)
    canvas.bind('<ButtonRelease-3>', motion.button_up)
    canvas.bind('<Button-4>', motion.zoom_in)
    canvas.bind('<Button-5>', motion.zoom_out)
    canvas.bind('<Key>', motion.search)
    
    root.mainloop()
    ap.join()

main()
