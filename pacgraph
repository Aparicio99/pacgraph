#! /usr/bin/env python

import random, math, subprocess, os, cProfile, optparse
from itertools import *
from collections import deque, defaultdict

# depends contains %CONFLICTS%, 
# %DEPENDS%, %OPTDEPENDS%, %PROVIDES%

# desc contains %URL%, %REPLACES%, %LICENSE%,
# %NAME%, %GROUPS%, %BUILDDATE%, %REASON%, %DESC%,
# %SIZE%, %PACKAGER%, %ARCH%, %INSTALLDATE%, %VERSION%

pj = os.path.join

class Node(object):
    def __init__(self, **kwargs):
        self.name    = ''      # matches dict key
        self.links   = set([]) # of name strings
        self.inverse = set([]) # of name strings
        self.size    = 0       # bytes, usually
        self.font_pt = 0       # scaled from size
        self.center  = (0,0)   # (x,y)
        #self.dim     = (0,0)   # (w,h)
        #self.color   = ''      # "#ffffff"
        self.__dict__.update(kwargs)
    def __repr__(self):
        return repr({'links' : self.links, 
                     'size'  : self.size})
    # cache the slowest of these?
    @property
    def all(self):
        return self.links | self.inverse
    @property
    def dim(self):
        return pt2dim(self.name, self.font_pt)
    @property
    def box(self):
        return bbox(self.center, self.dim)
    @property
    def cd(self):
        return [self.center, self.dim]

class MockOptions(object):
    def __init__(self):
        self.opt_deps = False

def unrip(path):
    "path -> dict of Nodes"
    text = ''.join(open(path))
    tree = eval(text)
    return bilink_tree(dict((p,Node(**n)) for p,n in tree.items()))

def l_part(n, c):
    return n.partition(c)[0]

def reduce_by(fn, data, arg_list):
    data = fn(data, arg_list.pop(0))
    if not arg_list:
        return data
    return reduce_by(fn, data, arg_list)

class Arch(object):
    def clean(self, n):
        return reduce_by(l_part, n.strip(), list('><:='))
    
    def load_info(self, arch_file):
        info = defaultdict(list)
        mode = None
        for line in (self.clean(l) for l in arch_file):
            if not line:
                continue
            if line.startswith('%'):
                mode = line
                continue
            info[mode].append(line)
        arch_file.close()
        return info
    
    def strip_info(self, info):
        keep = ['DEPENDS', 'OPTDEPENDS', 'PROVIDES', 'SIZE', 'ISIZE']
        info = dict((k.strip('%'),v) for k,v in info.items())
        name = info['NAME'][0]
        info = dict((k,v) for k,v in info.items() if k in keep)
        if 'ISIZE' in info:
            info['SIZE'] = info['ISIZE']
        if 'SIZE' in info:
            info['SIZE'] = int(info['SIZE'][0], 10)
        else:
            info['SIZE'] = 0
        return name, info
    
    def load_tree(self, dirs):
        packages = [p for r in dirs for p,d,f in os.walk(r) if f]
        tree = {}
        for p in set(packages) - set(dirs):
            try:
                info = {}
                arch_file = open(pj(p,'depends'), 'r')
                info.update(self.load_info(arch_file))
                arch_file = open(pj(p,'desc'), 'r')
                info.update(self.load_info(arch_file))
                name, info = self.strip_info(info)
                tree[name] = info
            except:
                print 'Error reading package', p
        return tree
    
    def actually_installed_fn(self, tree):
        "use only on load_tree data, returns function"
        p_set = set(tree)
        errors = {}
        p_tree = dict((p,tree[p]['PROVIDES']) for p in tree if 'PROVIDES' in tree[p])
        def actually(packages):
            installed = set(packages) & p_set
            maybe = set(packages) - installed
            for pack in maybe:
                if pack in errors:
                    installed.add(errors[pack])
                    continue
                provides = sorted(p for p in p_tree if pack in p_tree[p])
                if len(provides) > 1:
                    print 'error: %s found in %s, assuming %s' % (pack, provides, provides[0])
                    errors[pack] = provides[0]
                if len(provides) >= 1:
                    installed.add(provides[0])
                # len 0 means not installed optdep
            return list(installed)
        return actually
    
    def merge_tree(self, tree, options):
        "merge provides, depends, optdepends"
        tree2 = {}
        actually_installed = self.actually_installed_fn(tree)
        # merge
        for p in tree:
            tp = defaultdict(list, tree[p])
            deps = tp['DEPENDS']
            if options.opt_deps:
                deps += tp['OPTDEPENDS']
            # remove unused optdeps
            deps = actually_installed(deps)
            tree2[p] = Node(name=p, size=tree[p]['SIZE'], links=set(deps))
        return tree2
    
    def local_load(self, options):
        dirs = ['/var/lib/pacman/local/']
        tree = compress_chains(bilink_tree(self.merge_tree(self.load_tree(dirs), options)))
        return legal_links(tree)
    
    def repo_load(self, options, packages=None):
        dirs = ['/var/lib/pacman/sync/community/',
                '/var/lib/pacman/sync/core/',
                '/var/lib/pacman/sync/extra/']
        tree = self.merge_tree(self.load_tree(dirs), options)
        if not packages:
            return legal_links(compress_chains(bilink_tree(tree)))
        deps = [d for p in packages for d in full_deps(p, tree)]
        tree2 = dict((k,v) for k,v in tree.iteritems() if k in deps)
        return legal_links(bilink_tree(tree2))

class Debian(object):
    "Completely untested, a quick hack from reading docs."
    def call(self, cmd):
        "returns stdout"
        subp = subprocess.Popen(cmd, stdin=None, stdout=subprocess.PIPE, shell=True)
        return subp.communicate()[0].split('\n')
    
    def all_installed(self):
        stdout = self.call('dpkg --get-selections')
        return [line.split()[0] for line in stdout if line.endswith('install') and not line.endswith('deinstall')]
    
    def pkg_info(self, name):
        stdout = self.call('dpkg -s %s' % name)
        size = [line for line in stdout if line.startswith('Installed-Size:')]
        size = int(size[0].split(' ')[1], 10) * 1024
        deps = [line for line in stdout if line.startswith('Depends:')]
        if deps:
            deps = deps[0].partition(' ')[2]
            deps = [d for e in deps.split(',') for d in e.split('|')]
            deps = [d.partition('(')[0] for d in deps]
            deps = set(d.strip() for d in deps) - set([''])
        else:
            deps = set([])
        return Node(name=name, links=deps, size=size)
    
    def load_tree(self):
        tree = {}
	for p in self.all_installed():
            try:
                tree[p] = self.pkg_info(p)
            except:
                print 'Error reading package', p
        return tree
    
    def local_load(self, options):
        tree = legal_links(self.load_tree())
        tree = compress_chains(bilink_tree(tree))
        return legal_links(tree)
    
    def repo_load(self, options, packages=None):
        print 'not implemented'
        raise

class Redhat(object):
    "Completely untested, a quick hack from reading docs."
    def call(self, cmd):
        "returns stdout"
        subp = subprocess.Popen(cmd, stdin=None, stdout=subprocess.PIPE, shell=True)
        return subp.communicate()[0].split('\n')
    
    def all_installed(self):
        stdout = self.call('rpm --query --all')
        return [line.split()[0] for line in stdout if line not in ['']]
    
    def pkg_info(self, name):
        stdout = self.call('rpm --query --queryformat "%%{SIZE}\n" %s' % name)
        size = int(stdout[0], 10)
        requires = self.call('rpm --query --queryformat "[%%{REQUIRENAME}\n]" %s' % name)
        if requires:
            requires = [capability for capability in requires if capability not in [''] and '.so.' not in capability and '(' not in capability]
            requires = list(set(requires))
            deps = [self.call('rpm --query --whatprovides %s' % capability)[0] for capability in requires]
            deps = set(deps) - set([''])
        else:
            deps = set([])
        return Node(name=name, links=deps, size=size)
    
    def load_tree(self):
        tree = {}
	for p in self.all_installed():
            try:
                tree[p] = self.pkg_info(p)
            except:
                print 'Error reading package', p
        return tree
    
    def local_load(self, options):
        tree = legal_links(self.load_tree())
        tree = compress_chains(bilink_tree(tree))
        return legal_links(tree)
    
    def repo_load(self, options, packages=None):
        print 'not implemented'
        raise

def full_deps(package, tree):
    "returns every package in dep tree"
    deps = set()
    to_crawl = deque([package])
    while to_crawl:
        current = to_crawl.popleft()
        if current in deps:
            continue
        deps.add(current)
        current_deps = tree[current].links
        to_crawl.extend(current_deps - deps)
    return list(deps)

def bilink_tree(tree):
    "adds inverse from links"
    for p in tree:
        deps = tree[p].links
        [tree[d].inverse.add(p) for d in deps]
    return tree

def flatten(list_of_lists):
    return list(chain(*list_of_lists))

def single_depends(tree):
    return (p for p in tree if len(tree[p].inverse) == 1)

def compress_chains(tree):
    "single depends are absorbed into parent"
    while True:
        singles = single_depends(tree)
        try:
            s = singles.next()
        except StopIteration:
            return tree
        parent = list(tree[s].inverse)[0]
        if s == parent:
            #print 'self loop', s
            tree[s].links.remove(s)
            tree[s].inverse.remove(s)
            continue
        #print 'merge', s, 'into', parent
        tree[parent].size += tree[s].size
        for dep in tree[s].links:
            tree[dep].inverse.remove(s)
            tree[dep].inverse.add(parent)
        tree[parent].links.update(tree[s].links)
        tree[parent].links.remove(s)
        tree.pop(s)

def sum_sizes(packages, tree):
    return sum(tree[p].size for p in packages if p in tree)

def shared_size(package, tree):
    "package and all deps"
    return sum_sizes(full_deps(package, tree), tree)

def biggest_packs(tree):
    packs = [(shared_size(p, tree), p) for p in tree]
    return [p for s,p in reversed(sorted(packs))]

def toplevel_packs(tree):
    return set(p for p in tree if not tree[p].inverse)

def packs_by_size(tree, pack_list):
    by_sizes = [(tree[n].size, n) for n in pack_list]
    return reversed(sorted(by_sizes))

def legal_links(tree):
    "removes/reports dangling references"
    valid = set(tree)
    for k,v in tree.iteritems():
        invalid1 = v.links - valid
        invalid2 = v.inverse - valid
        if invalid1:
            print 'error: unknown', list(invalid1), 'in', k 
            v.links = v.links - invalid1
        if invalid2:
           print 'error: unknown', list(invalid2), 'in', k
           v.inverse = v.inverse - invalid2
    return tree

#print 'worst shared packages:', biggest_packs(tree)[:20]
#print 'most crucial packages:', biggest_packs(invert_tree(tree))[:20]

def pt_sizes(tree, min_pt=10, max_pt=100):
    "size in bytes -> size in points"
    sizes = [node.size for p,node in tree.iteritems()]
    min_s,max_s = min(sizes), max(sizes)
    convert = lambda s: int((max_pt-min_pt)*(s-min_s)/(max_s-min_s) + min_pt)
    for p, node in tree.iteritems():
        tree[p].font_pt = convert(node.size)
    return tree

def prioritized(packs):
    "returns list of names, sorted by priority"
    # first are the most central, with lots of links
    stats = [(len(node.all), k) for k,node in packs.items()]
    stats = [n for l,n in reversed(sorted(stats))]
    # but slip in anyone who's deps are met early
    stats2 = []
    for n in (n for n in stats if n not in stats2):
        stats2.append(n)
        plotted = set(stats2)
        deps_met = [k for k,node in packs.items() if node.all <= plotted]
        stats2.extend(set(deps_met) - plotted)
    return stats2

def ran_rad():
    return random.random()*2*math.pi

def bbox(center, dim):
    c,d = center,dim
    x1,x2 = c[0]-d[0]//2, c[0]+d[0]//2
    y1,y2 = c[1]-d[1]   , c[1]+d[1]//3
    return [x1, y1, x2, y2] 

def common_ranges(r1, r2):
    "returns true if overlap"
    if r1 < r2:
        return r1[1] > r2[0]
    return r2[1] > r1[0]

def in_box(bbox1, bbox2):
    cr = common_ranges
    r1x = bbox1[0::2]
    r1y = bbox1[1::2]
    r2x = bbox2[0::2]
    r2y = bbox2[1::2]
    return cr(r1x, r2x) and cr(r1y, r2y)

def all_bboxes(name, packs, pri=None):
    if pri is None:
        name_list = packs.keys()
    else:
        name_list = pri[:pri.index(name)]
    return [packs[n].box for n in name_list]

def normalize(point, origin):
    p2 = point[0]-origin[0], point[1]-origin[1]
    length = (p2[0]**2 + p2[1]**2)**0.5
    return p2[0]/(length**2), p2[1]/(length**2)

def link_pull(name, origin_n, packs):
    "average of angles of links"
    origin = packs[origin_n].center
    norm_ps = lambda ps: [normalize(c, origin) for c in ps if c not in [(0,0), origin]]
    rot90 = lambda x,y: (-y,x) if random.randint(0,1) else (y,-x)
    good_links = packs[name].all
    skew_links = set(packs.keys()) - good_links
    g_centers  = norm_ps(packs[l].center for l in good_links)
    s_centers  = norm_ps(packs[l].center for l in skew_links)
    s_centers  = [rot90(*xy) for xy in s_centers]
    centers = g_centers + s_centers
    if not centers:  
        # new branch, try to avoid existing branches
        centers = norm_ps(packs[l].center for l in packs.keys())
        if not centers:
            return (0,0)
        centers = [(-x,-y) for x,y in centers]
    return map(sum, zip(*centers))

def xy2rad(x,y):
    "adds some wiggle so things are less spindly"
    if (x,y) == (0,0):
        return ran_rad()
    wiggle = 0.35  # radians
    wiggle = random.random()*wiggle - wiggle/2.0
    return math.atan2(y,x) + wiggle

def pol2xy(o,a,r):
    return int(o[0]+r*math.cos(a)), int(o[1]+r*math.sin(a))

def pt2dim(name, pt):
    x_scale = 0.65
    y_scale = 0.85
    return int(len(name)*pt*x_scale), int(pt*y_scale)

def best_origin(name, pri, packs):
    "returns largest sibling, or root"
    possible = pri[:pri.index(name)]
    possible = [n for n in possible if n in packs[name].all]
    if not possible:
        return pri[0]  # root package
    return sorted((packs[n].size, n) for n in possible)[-1][1]

def search(cd, origin, heading, scale, b_list):
    "binary search recursive closure thingy, returns radius"
    def probe(r):
        "returns true if clear"
        cd[0] = pol2xy(origin, heading, r)
        bb1 = bbox(*cd)
        return not any(in_box(bb1, bb2) for bb2 in b_list)
    def search2(step, r):
        if probe(r-step//2):
            if step < 8*scale:
                return r-step//2
            return search2(step//2, r-step//2)
        if probe(r+step//2):
            return search2(step//2, r+step//2)
        return search2(step*2, r+step*2)
    return search2(scale*5, scale*5)

def place(packs):
    "radial placement algo, returns non-overlapping coords"
    # maybe try two different link_pulls for each placement?
    pri = prioritized(packs)
    for name in pri[1:]:
        origin_name = best_origin(name, pri, packs)
        #print 'placing', name, 'around', origin_name
        origin = packs[origin_name].center
        heading = xy2rad(*link_pull(name, origin_name, packs))
        scale = len(packs[name].all)+1  # more links need more room
        b_list = all_bboxes(name, packs, pri)
        r = search(packs[name].cd, origin, heading, scale, b_list)
        packs[name].center = pol2xy(origin, heading, r)
    return packs

def offset_coord(c,d):
    "corrects textbox origin"
    return c[0]-d[0]//2, c[1]  #+d[1]//2

def xml_wrap(tag, inner, **kwargs):
    kw = ' '.join('%s="%s"' % (k, str(v)) for k,v in kwargs.items())
    if inner is None:
        return '<%s %s/>' % (tag, kw)
    return '<%s %s>%s</%s>' % (tag, kw, inner, tag)

def control_point(p1, p2, drop=None):
    dx = abs(p2[0] - p1[0])
    lower  = (p1,p2)[p1[1]<p2[1]]
    higher = (p2,p1)[p1[1]<p2[1]]
    if drop is None:
        drop = 0.5 + 0.5*random.random()
    return (lower[0]+higher[0])//2, lower[1]+dx*drop//2

def quad_spline(p1, p2):
    "boofor DSL in XML"
    c = control_point(p1, p2)
    return 'M%i,%i Q%i,%i %i,%i' % (p1+c+p2)

def svg_text(text, center_dim, pt):
    p = offset_coord(*center_dim)
    kw = {'x':p[0], 'y':p[1], 'font-size':pt}
    return xml_wrap('text', text, **kw) 

def svg_spline(point1, point2):
    return xml_wrap('path', None, d=quad_spline(point1, point2))

def all_points(packs):
    "slightly incomplete, guestimates the splines"
    all_bb = flatten((bb[:2],bb[2:]) for bb in all_bboxes(None,packs))
    all_endpoints = [(packs[p].center, packs[l].center) for p in packs for l in packs[p].all]
    all_controls = [control_point(ep[0], ep[1], 0.5) for ep in all_endpoints]
    return all_bb + all_controls

def recenter(packs, points):
    "shift everything into quadrant 1"
    min_x,min_y = map(min, zip(*points))
    for name in packs:
        p = packs[name].center
        packs[name].center = p[0]-min_x, p[1]-min_y
    return packs

def window_size(points):
    xs,ys = zip(*points)
    return max(xs)-min(xs), max(ys)-min(ys)

def all_links(packs):
    paths = []
    for pack in packs:
        links = packs[pack].all
        p1 = packs[pack].center
        paths.extend((p1,packs[l].center) for l in links if l<pack)
    return paths

def svgify(packs, options):
    toplevel = toplevel_packs(packs)
    bottomlevel = set(packs) - toplevel
    all_ps = all_points(packs)
    packs = recenter(packs, all_ps)
    width,height = window_size(all_ps)
    text1 = [svg_text(p, packs[p].cd, packs[p].font_pt) for p in bottomlevel]
    text2 = [svg_text(p, packs[p].cd, packs[p].font_pt) for p in toplevel]
    paths = [svg_spline(*line) for line in all_links(packs)]
    svg =  xml_wrap('rect', None, x=0, y=0, width=width, height=height, style='fill:%s;' % options.background)
    svg += xml_wrap('g', '\n'.join(paths), style='stroke:%s; stroke-opacity:0.15; fill:none;' % options.link)
    svg += xml_wrap('g', '\n'.join(text1), **{'font-family':'Monospace', 'fill':options.dependency})
    svg += xml_wrap('g', '\n'.join(text2), **{'font-family':'Monospace', 'fill':options.toplevel})
    svg = xml_wrap('svg', svg, width=width, height=height)
    open('pacgraph.svg', 'w').write(svg)

def call(cmd):
    spp = subprocess.PIPE
    return subprocess.Popen(cmd, shell=True, stdout=spp, stderr=spp).wait()

def parse():
    default_action = 'arch'
    parser = optparse.OptionParser(description='Produces two files, pacgraph.svg and pacgraph.png.  Colors should be entered as hex values like "#ffffff".  SVG named colors may also work, see http://en.wikipedia.org/wiki/Web_colors')
    parser.add_option('-s', '--svg', dest='svg_only', action='store_true', default=False,
            help='Produce the SVG but do not attempt to rasterize it.')
    parser.add_option('-o', '--opt-deps', dest='opt_deps', action='store_true', default=False,
            help='Include optional dependencies.  May produce a less compact graph.')
    parser.add_option('-c', '--console', dest='console', action='store_true', default=False,
            help='Print summary to console, does not draw a graph.  Good for very slow computers.')
    parser.add_option('-r', '--rip', dest='rip', action='store_true', default=False,
            help='Rips a copy of your installed packages to pacgraph.txt.  Good for debugging.')
    
    colors = optparse.OptionGroup(parser, "Theming Options")
    colors.add_option('-b', '--background', dest='background', metavar='COLOR', default='#ffffff',
            help='Background color.')
    colors.add_option('-l', '--link', dest='link', metavar='COLOR', default='#606060',
            help='Color of links between packages.')
    colors.add_option('-t', '--top', dest='toplevel', metavar='COLOR', default='#0000ff',
            help='Color of packages which are not dependencies.')
    colors.add_option('-d', '--dep', dest='dependency', metavar='COLOR', default='#6a6aa2',
            help='Color of packages which are dependencies.')
    colors.add_option('-p', '--point', dest='point_size', metavar='INT INT', type='int', nargs=2, default=(10,100),
            help='Takes two integers, for the smallest and largest font size.  Default is -p 10 100.')
    parser.add_option_group(colors)

    beta = optparse.OptionGroup(parser, "Experimental Options")
    beta.add_option('-m', '--mode', dest='mode', default=default_action,
            help='Curently supported modes are arch, arch-repo (buggy), debian (buggy), and redhat (buggy).  Default is %s.' % default_action)
    parser.add_option_group(beta)
    
    options, args = parser.parse_args()
    return options, args

def human_si(number):
    powers = [(2**15,''), (2**25,'k'), (2**35,'M'), (2**45,'G')]
    limit,si = [p for p in powers if p[0] > number][0]
    return str(number//(limit//2**15)) + si +'b'

def main():
    arch = Arch()
    debian = Debian()
    redhat = Redhat()
    options, args = parse()
    print 'Loading package info'
    if options.mode == 'arch':
        tree = arch.local_load(options)
    if options.mode == 'arch-repo':
        tree = arch.repo_load(options, args)
    if options.mode == 'debian':
        tree = debian.local_load(options)
    if options.mode == 'redhat':
        tree = redhat.local_load(options)
    stat_line = human_si(sum(v.size for k,v in tree.items()))
    if options.rip:
        open('pacgraph.txt', 'w').write(repr(tree))
        return
    if options.console:
        print 'Total size:', stat_line
        tops = toplevel_packs(tree)
        if len(tops) == 1:
            tops = tree.keys()
        for s,n in packs_by_size(tree, tops):
            print human_si(s), n
        return
    print 'Placing %i nodes' % len(tree)
    tree = pt_sizes(tree, *options.point_size)
    packs = place(tree)
    tree = recenter(tree, all_points(tree))
    tree[stat_line] = Node(name=stat_line, font_pt=sum(options.point_size)//2)
    print 'Saving SVG'
    svgify(packs, options)
    if options.svg_only:
        return
    print 'Rendering PNG'
    if call('which inkscape') == 0:
        call('inkscape -D -e pacgraph.png pacgraph.svg')
        return
    if call('which svg2png') == 0:
        call('svg2png pacgraph.svg pacgraph.png')
        return
    if call('which convert') == 0:
        call('convert pacgraph.svg pacgraph.png')
        return
    print 'No way to convert SVG to PNG.'
    print 'Inkscape, svg2png or imagemagick would be nice.'

if __name__ == "__main__":
    main()
    #cProfile.run("main()", sort=1)

"""
possible/future command line options

-f  --file        output file name
-a  --add         packages
-c  --chains      retain package chains
-d  --dot         load dot file

line weight? alpha? tree dump/load?
"""
